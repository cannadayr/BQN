<head>
  <meta charset="utf-8">
  <link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../../style.css" rel="stylesheet"/>
  <title>BQN: Loop fusion in array languages</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../../index.html">BQN</a> / <a href="../index.html">implementation</a> / <a href="index.html">compile</a></div>
<h1 id="loop-fusion-in-array-languages"><a class="header" href="#loop-fusion-in-array-languages">Loop fusion in array languages</a></h1>
<p>Interpreted array languages have a major problem. Let's say you evaluate some arithmetic on a few arrays. Perhaps the first operation adds two arrays. It will loop over them, ideally adding numbers a vector register at a time, and write the results to an array. Maybe next it will check if the result is more than 10. So it'll read vectors from the result, compare to 10, pack to bit booleans, and write to another array. Each primitive has been implemented well but the combination is already far from optimal! The first result array isn't needed: it would be much better to compare each added vector to 10 right when it's produced. The extra store and load (and index arithmetic) are instructions that we don't need, but by using extra memory we can also create cache pressure that slows down the program even more.</p>
<p>Scalar languages don't have this problem. The programmer just writes the addition and comparison in a loop, the compiler compiles it, and every comparison naturally follows the corresponding addition. More modern languages might prefer approaches like iterators that abstract away the looping but still have the semantics of a fused loop. But an iterator call, let's say <code><span class='Value'>zipwith</span><span class='Paren'>(</span><span class='Function'>+</span><span class='Separator'>,</span> <span class='Value'>a.iter</span><span class='Paren'>()</span><span class='Separator'>,</span> <span class='Value'>b.iter</span><span class='Paren'>())</span><span class='Value'>.map</span><span class='Paren'>(</span><span class='Function'>&gt;</span><span class='Number'>10</span><span class='Paren'>)</span></code> to make up some syntax, has a pretty obvious array equivalent, and if the functions are pure the different semantics don't matter! This has led to several compiled array languages like <a href="https://www.snakeisland.com/apexup.htm">APEX</a> that work on the principle of re-interpreting the scalar parts of array operations in a way that fuses naturally.</p>
<p>Scalar compilation gives up many advantages inherent to array programming, a topic I discussed more broadly <a href="intro.html">here</a>. The obvious complaint is that you lose the vector instructions, but that's easy enough to dismiss. Any decent C compiler can auto-vectorize a loop, and so could an array compiler. But arithmetic is rarely the bottleneck, so let's say that the comparison's result will be used to filter a third array, that is, the expression is now <code><span class='Paren'>(</span><span class='Number'>10</span><span class='Function'>&lt;</span><span class='Value'>a</span><span class='Function'>+</span><span class='Value'>b</span><span class='Paren'>)</span><span class='Function'>/</span><span class='Value'>c</span></code>. Filtering doesn't auto-vectorize! Two vectors of input will produce an output with a different, unknown size, which is enough to throw off the analysis. At least the C compilers I've dealt with will fall back to producing completely scalar code. Depending on type, this can actually be slower than CBQN's un-fused, but SIMD, primitives.</p>
<p>This example doesn't entirely reveal the extent of the problem (for one thing, writing filter's result a partial vector at a time isn't bad, the real difficulty would be fusing it with more arithmetic later on). But hopefully it gives a sense of the issues that arise. I believe fusing operations without losing CBQN's powerful single-primitive operations will require a system that considers not just the possibility of fusing at the scalar level but several layers, from a single vector up to larger blocks of memory.</p>
<h2 id="blocking-and-cache-levels"><a class="header" href="#blocking-and-cache-levels">Blocking and cache levels</a></h2>
<p>The loosest form of loop fusion goes by various names such as blocking, chunking, or tiling. Instead of running each primitive on the entire array, we run it on a block of a few kilobytes. Looping within a block stays separate, but the outer layer of looping over blocks can be fused. So in <code><span class='Paren'>(</span><span class='Number'>10</span><span class='Function'>&lt;</span><span class='Value'>a</span><span class='Function'>+</span><span class='Value'>b</span><span class='Paren'>)</span><span class='Function'>/</span><span class='Value'>c</span></code> we'd add blocks from <code><span class='Value'>a</span></code> and <code><span class='Value'>b</span></code>, compare each one to 10, and use the result to filter a block of <code><span class='Value'>c</span></code>, before moving on to the next set of blocks. This has the advantage that it doesn't actually require compilation, as blocks can still be processed with pre-compiled functions. It has the disadvantage that each block operation still reads and writes to memory—hang on, what problem are we actually trying to solve here?</p>
<p>For basic arithmetic, working from memory is a big relative cost, because even at the fastest cache level a load or store costs about as much the arithmetic itself. Heavier primitives like scans, filtering, transpose, or searching in a short list, do a lot more work in between, so if load and store <em>only</em> cost about as much as arithmetic that's actually pretty good. But large arrays don't fit in the fastest cache level. If a primitive writes a large result, then by the time it's done only a little piece at the end is still saved in L1. The next primitive will start at the beginning and miss L1 entirely! If the interpreter instead works in blocks that are significantly smaller than the L1 cache, accesses between primitives should stay within L1 and only the boundary of fusion, meaning the initial reads and final write, can be slow.</p>
<p>Blocking is still compatible with finer-grained fusion. Primitives should simply be fused as block operations and not whole-array operations.</p>
<p>Sounds simple, but blocking has its difficulties even once the primitives to be blocked have been identified. As is becoming a pattern, one-to-one arithmetic suffers from none of these and is trivial.</p>
<ul>
<li>Do we want to block at all? For very small arrays, setting up the block system may be expensive. Otherwise it's fine to &quot;block&quot; the computation even if a block is a whole array (and it may be a good idea to allow a single oversize block at the end instead of making one that's very small)</li>
<li>Shifting and rotation have unaligned input and output: one output should be formed from two inputs</li>
<li>Replicate changes the block size: if it shrinks it, multiple output blocks should be gathered together; if it expands it, how will we even know the right input size?</li>
<li>Functions like scans have state that needs to be carried across blocks</li>
<li>Two stateful functions might end up with different iteration orders, preventing fusion (e.g. combining forward and reverse scan with <code><span class='Function'>∧</span><span class='Modifier'>`</span><span class='Function'>∨∧</span><span class='Modifier'>`</span><span class='Modifier2'>⌾</span><span class='Function'>⌽</span></code>, or float <code><span class='Function'>+</span><span class='Modifier'>´</span><span class='Function'>+</span><span class='Modifier'>`</span></code> as BQN's fold is unfortunately backwards)</li>
</ul>
<p>Multidimensional operations are a whole new world of trouble. With a 2D transpose, for example, you probably want to work on square-ish blocks. The short side should be at least a cache line long to avoid re-reading or re-writing cache lines. Tiling like this is also okay for shifts, scans, and folds in either direction, but in some cases maybe it would be better for a block to be a section of a row, or even a column.</p>
<p>A computation that can be blocked but can't be freely reordered because of side effects, <code><span class='Function'>•Show</span><span class='Modifier'>¨</span></code> for example, can be fused with primitives if the elements are passed to it in the right order. But two such functions can't be fused because the first needs to run on every block before the second gets any. Fusion needs to be cut at some point between them, perhaps in a place where memory use is lowest. And a function that can't be blocked at all obviously can't be fused, but there may still be some value in reordering relative to primitives: for example <code><span class='Paren'>(</span><span class='Function'>F</span> <span class='Value'>c</span><span class='Paren'>)</span> <span class='Function'>×</span> <span class='Value'>a</span><span class='Function'>+</span><span class='Value'>b</span></code> is defined to compute <code><span class='Function'>+</span></code> before <code><span class='Function'>F</span></code> but doing them in the other order has the same result and allows <code><span class='Function'>+</span></code> and <code><span class='Function'>×</span></code> to be fused. This should only be done if any reordered primitives (<code><span class='Function'>+</span></code> here) are known not to have errors, to avoid calling <code><span class='Function'>F</span></code> and then throwing an error that should have happened first.</p>
