<head>
  <meta charset="utf-8">
  <link href="../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../style.css" rel="stylesheet"/>
  <title>BQN: Foreign Function Interface (FFI)</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../index.html">BQN</a> / <a href="index.html">doc</a></div>
<h1 id="foreign-function-interface-ffi"><a class="header" href="#foreign-function-interface-ffi">Foreign Function Interface (FFI)</a></h1>
<p>BQN's <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">foreign function interface</a> allows it to interface with libraries written in C, or other languages that support a compatible format. It's invoked with <code><span class='Function'>‚Ä¢FFI</span></code>, which performs the necessary lookups and conversions to call a function from a dynamic shared library (extension .so in Unix-like systems and .dll in Windows). This function is <a href="../spec/system.html#foreign-function-interface-ffi">specified</a> by BQN and implemented by CBQN‚Äîwithout support for all possible types, but enough for practical use.</p>
<p>Warning: object code is unsafe by nature. The OS will hopefully prevent it from exceeding the privileges of the BQN interpreter, but anything code in the interpreter could do is fair game. It might crash, write files, corrupt BQN arrays resulting in &quot;impossible&quot; behavior later on, or read everything in your home directory and email it to someone. Be careful when invoking the FFI!</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h2>
<p><code><span class='Function'>‚Ä¢FFI</span></code> takes the path of the object file as <code><span class='Value'>ùï®</span></code>, with local paths resolved relative to the source file as in <code><span class='Function'>‚Ä¢Import</span></code>. <code><span class='Value'>ùï©</span></code> describes the specific function requested from this file and its type signature, and the result is a BQN function that calls it. While a major purpose of <code><span class='Function'>‚Ä¢FFI</span></code> is to be called with files like libpng.so that you may already have on your system, we'll start by writing some C to make it clear what's happening on both sides of the interface. A factorial function is pretty short, so let's start there:</p>
<pre><span class='Comment'>#include &quot;stdint.h&quot;
</span>
<span class='Value'>int32_t</span> <span class='Value'>fac32</span><span class='Paren'>(</span><span class='Value'>int32_t</span> <span class='Value'>n</span><span class='Paren'>)</span> <span class='Brace'>{</span> <span class='Value'>return</span> <span class='Value'>n</span> <span class='Head'>?</span> <span class='Value'>n</span> <span class='Value'>*</span> <span class='Value'>fac32</span><span class='Paren'>(</span><span class='Value'>n</span> <span class='Function'>-</span> <span class='Number'>1</span><span class='Paren'>)</span> <span class='Head'>:</span> <span class='Number'>1</span><span class='Head'>;</span> <span class='Brace'>}</span>
</pre>
<p>To follow along on Linux, save as fac.c and compile with <code><span class='Value'>gcc</span> <span class='Value'>fac.c</span> <span class='Function'>-</span><span class='Value'>shared</span> <span class='Function'>-</span><span class='Value'>o</span> <span class='Value'>fac.so</span></code>. On other operating systems, do whatever does the same thing as that I guess. Then you can call it from BQN like this:</p>
<pre><span class='Value'>fac32</span> <span class='Gets'>‚Üê</span> <span class='String'>&quot;fac.so&quot;</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;i32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;fac32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;i32&quot;</span>
<span class='Function'>‚Ä¢Show</span> <span class='Function'>Fac32</span> <span class='Bracket'>‚ü®</span><span class='Number'>5</span><span class='Bracket'>‚ü©</span>  <span class='Comment'># 120
</span></pre>
<p>This assumes the BQN code is running in the same directory as fac.so. The use of <code><span class='Value'>fac32</span></code> on the first line and <code><span class='Function'>Fac32</span></code> on the second is <a href="expression.html#syntactic-role">syntactic role</a> manipulation: we have to treat the result of a function such as <code><span class='Function'>‚Ä¢FFI</span></code> as a subject when it's first created, but then we put it in a function role to call it (see also <a href="functional.html#functional-programming-in-bqn">functional programming</a>). Elements of <code><span class='Function'>‚Ä¢FFI</span></code>'s right argument follow the form of a C declaration: result type, function name, and then argument types. C functions can take any number of arguments, so for consistency <code><span class='Function'>Fac32</span></code> takes a list as its argument instead of taking a number directly. But using a <code><span class='Function'>Fac32</span><span class='Modifier2'>‚àò</span><span class='Function'>‚ãà</span></code> wrapper would be annoying and add a little overhead, so a special <code><span class='Function'>&gt;</span></code> declaration on the type indicates that the BQN argument should be used directly. Now our function has the same interface as <code><span class='Value'>‚Ä¢math.</span><span class='Function'>Fact</span></code>, making it easy to verify that it was pointless work:</p>
<pre><span class='Value'>fac32</span> <span class='Gets'>‚Üê</span> <span class='String'>&quot;fac.so&quot;</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;i32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;fac32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&gt;i32&quot;</span>
<span class='Function'>!</span> <span class='Paren'>(</span><span class='Function'>Fac32</span> <span class='Function'>‚â°</span> <span class='Value'>‚Ä¢math.</span><span class='Function'>Fact</span><span class='Paren'>)</span> <span class='Number'>5</span>
</pre>
<p>And because the C function <code><span class='Value'>fac32</span></code> takes a signed integer but doesn't test for negative arguments, running <code><span class='Function'>Fac32</span> <span class='Number'>¬Ø1</span></code> shows some potential negative effects of a bad FFI call. When I compile with no optimization as shown above, it runs out of stack space and crashes BQN with a segmentation fault. With <code><span class='Function'>-O2</span></code> or higher, it takes several seconds to wrap around to positivies and eventually returns 0, but signed overflow is undefined behavior, so anything could happen really.</p>
<h3 id="using-pointers"><a class="header" href="#using-pointers">Using pointers</a></h3>
<p>For a more complicated example, here's a function that counts the number of cycles in a permutation, by tracing each cycle starting at its lowest index. In typical C fashion, it takes its argument as a length and then a pointer to the permutation indices, since a pointer by itself doesn't have any length information.</p>
<pre><span class='Comment'>#include &quot;stdint.h&quot;
</span>
<span class='Value'>uint32_t</span> <span class='Value'>cycles</span><span class='Paren'>(</span><span class='Value'>uint32_t</span> <span class='Value'>len</span><span class='Separator'>,</span> <span class='Value'>uint32_t*</span> <span class='Value'>p</span><span class='Paren'>)</span> <span class='Brace'>{</span>
    <span class='Value'>uint32_t</span> <span class='Value'>count</span> <span class='Function'>=</span> <span class='Number'>0</span><span class='Head'>;</span>
    <span class='Value'>for</span> <span class='Paren'>(</span><span class='Value'>uint32_t</span> <span class='Value'>i</span> <span class='Function'>=</span> <span class='Number'>0</span><span class='Head'>;</span> <span class='Value'>i</span> <span class='Function'>&lt;</span> <span class='Value'>len</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>++</span><span class='Paren'>)</span> <span class='Brace'>{</span>
        <span class='Value'>uint32_t</span> <span class='Value'>j</span> <span class='Function'>=</span> <span class='Value'>i</span><span class='Separator'>,</span> <span class='Value'>pj</span> <span class='Function'>=</span> <span class='Value'>p</span><span class='Bracket'>[</span><span class='Value'>j</span><span class='Bracket'>]</span><span class='Head'>;</span>
        <span class='Value'>count</span> <span class='Function'>+=</span> <span class='Value'>pj</span> <span class='Function'>&gt;=</span> <span class='Value'>i</span><span class='Head'>;</span>
        <span class='Value'>while</span> <span class='Paren'>(</span><span class='Value'>pj</span> <span class='Function'>&gt;</span> <span class='Value'>i</span><span class='Paren'>)</span> <span class='Brace'>{</span>
            <span class='Value'>p</span><span class='Bracket'>[</span><span class='Value'>j</span><span class='Bracket'>]</span> <span class='Function'>=</span> <span class='Value'>i</span><span class='Head'>;</span>
            <span class='Value'>j</span> <span class='Function'>=</span> <span class='Value'>pj</span><span class='Head'>;</span>
            <span class='Value'>pj</span> <span class='Function'>=</span> <span class='Value'>p</span><span class='Bracket'>[</span><span class='Value'>j</span><span class='Bracket'>]</span><span class='Head'>;</span>
        <span class='Brace'>}</span>
    <span class='Brace'>}</span>
    <span class='Value'>return</span> <span class='Value'>count</span><span class='Head'>;</span>
<span class='Brace'>}</span>
</pre>
<p>With that compiled to <code><span class='Value'>cyc.so</span></code>, we can call it using the following BQN code. The pointer type is represented with the asterisk at the beginning rather than at the end, so that reading from left to right reveals the outermost structure first.</p>
<pre><span class='Value'>cycC</span> <span class='Gets'>‚Üê</span> <span class='String'>&quot;cyc.so&quot;</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;u32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;cycles&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;*u32&quot;</span>
<span class='Function'>‚Ä¢Show</span> <span class='Value'>p</span> <span class='Gets'>‚Üê</span> <span class='Function'>‚çã</span><span class='String'>&quot;cycle&quot;</span>  <span class='Comment'># ‚ü® 0 2 4 3 1 ‚ü©
</span><span class='Function'>‚Ä¢Show</span> <span class='Function'>CycC</span> <span class='Function'>‚â†</span><span class='Modifier2'>‚ä∏</span><span class='Function'>‚ãà</span> <span class='Value'>p</span>    <span class='Comment'># 3
</span><span class='Function'>‚Ä¢Show</span> <span class='Value'>p</span>             <span class='Comment'># ‚ü® 0 2 4 3 1 ‚ü©
</span></pre>
<p>The cycles are 0, 124, and 3, so that checks out. But <code><span class='Value'>cycles</span></code> modifies its argument <code><span class='Value'>p</span></code>, with the line <code><span class='Value'>p</span><span class='Bracket'>[</span><span class='Value'>j</span><span class='Bracket'>]</span> <span class='Function'>=</span> <span class='Value'>i</span></code>. Is the BQN list <code><span class='Value'>p</span></code> changed when this happens? The check on the last line says no, which is good because BQN arrays are supposed to be immutable. What happens is that BQN copies the data into temporary memory in order to pass it in to C (here it also converts from 8 bits for each element to 32).</p>
<p>But what if we want to see those modifications? Many C functions use pointer modification as a way to return multiple values, so the FFI supports this. With <code><span class='Value'>&amp;</span></code> instead of <code><span class='Value'>*</span></code>, the values after calling the function are returned as an extra result.</p>
<pre><span class='Value'>cycles</span> <span class='Gets'>‚Üê</span> <span class='String'>&quot;cyc.so&quot;</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;u32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;cycles&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&amp;u32&quot;</span>
<span class='Function'>‚Ä¢Show</span> <span class='Function'>Cycles</span> <span class='Function'>‚â†</span><span class='Modifier2'>‚ä∏</span><span class='Function'>‚ãà</span> <span class='Function'>‚çã</span><span class='String'>&quot;cycle&quot;</span>  <span class='Comment'># ‚ü® 3 ‚ü® 0 1 1 3 1 ‚ü© ‚ü©
</span></pre>
<p>The original result might not be wanted in this case. You can ignore it by using <code><span class='String'>&quot;&quot;</span></code> for the result type, but then you get a 1-element list, for consistency with the case with multiple <code><span class='Value'>&amp;</span></code> arguments. Similar to <code><span class='Function'>&gt;</span></code> on a single argument, you can use <code><span class='String'>&quot;&amp;&quot;</span></code> for the result to get a single mutated argument returned directly.</p>
<pre><span class='Value'>cycI</span> <span class='Gets'>‚Üê</span> <span class='String'>&quot;cyc.so&quot;</span> <span class='Function'>‚Ä¢FFI</span> <span class='String'>&quot;&amp;&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;cycles&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&amp;u32&quot;</span>
<span class='Function'>‚Ä¢Show</span> <span class='Function'>CycI</span> <span class='Function'>‚â†</span><span class='Modifier2'>‚ä∏</span><span class='Function'>‚ãà</span> <span class='Function'>‚çã</span><span class='String'>&quot;cycle&quot;</span>  <span class='Comment'># ‚ü® 0 1 1 3 1 ‚ü©
</span></pre>
<p>(And now <code><span class='Function'>‚äî‚äê</span></code> gives a list of lists indicating which indices form each cycle, although that's not the same as a cycle decomposition, which would also indicate their ordering within the cycle.)</p>
<h2 id="type-specification"><a class="header" href="#type-specification">Type specification</a></h2>
<p>So the format of <code><span class='Value'>ùï©</span></code> is result type, function name, argument types. And the function name isn't complicated, it's just a string. Types have more rules. Here's the quick rundown:</p>
<ul>
<li>Numeric types are formatted like <code><span class='Value'>i32</span></code>, with <code><span class='Value'>i</span></code>, <code><span class='Value'>u</span></code>, or <code><span class='Value'>f</span></code>.</li>
<li>Another basic type, <code><span class='Value'>a</span></code>, exposes BQN values directly.</li>
<li>Typed pointers are written <code><span class='Value'>*t</span></code> or <code><span class='Value'>&amp;t</span></code>, and untyped pointers as <code><span class='Value'>*</span></code> or <code><span class='Value'>&amp;</span></code>.</li>
<li>Fixed-size arrays are written like <code><span class='Bracket'>[</span><span class='Number'>25</span><span class='Bracket'>]</span><span class='Value'>t</span></code>.</li>
<li>Structs are written like <code><span class='Brace'>{</span><span class='Value'>r</span><span class='Separator'>,</span><span class='Value'>s</span><span class='Separator'>,</span><span class='Value'>t</span><span class='Brace'>}</span></code>.</li>
<li>A <code><span class='Head'>:</span></code> suffix like <code><span class='Head'>:</span><span class='Value'>c16</span></code> indicates a corresponding BQN type.</li>
</ul>
<p>The numeric qualities are <code><span class='Value'>i</span></code> for signed integer, <code><span class='Value'>u</span></code> for unsigned integer, and <code><span class='Value'>f</span></code> for floating-point number. CBQN supports integer widths from 8 to 64, and float widths 32 and 64. <code><span class='Value'>u8</span></code> can be used for <code><span class='Value'>bool</span></code>.</p>
<p>Other than <code><span class='Value'>a</span></code>, which is implementation-dependent, all of these types have a direct correspondence to C. For example, <code><span class='Brace'>{</span><span class='Bracket'>[</span><span class='Number'>2</span><span class='Bracket'>]</span><span class='Value'>f32</span><span class='Separator'>,</span><span class='Value'>**i8</span><span class='Brace'>}</span></code> is a struct whose two fields are a list of two 32-bit floats and a pointer to pointers to 8-bit integers.</p>
<p>Shared libraries don't include type signatures, so <code><span class='Function'>‚Ä¢FFI</span></code> can't verify that the type signature for a given function is correct: it just passes the arguments however it should for that type signature. One consequence is that an imprecise type signature may still work. Pointers are all passed the same way, so their element types don't matter on the C side of the FFI; it's fine to use whatever's most convenient on the BQN side.</p>
<h3 id="type-conversions"><a class="header" href="#type-conversions">Type conversions</a></h3>
<p>So what do all these C types mean in BQN? The FFI tries to define sensible conversions. But BQN can't always represent every value directly, so it also provides <a href="#explicit-type-conversion">explicit conversions</a> with <code><span class='Head'>:</span></code> using the underlying bit representation, giving a way to safely store any value.</p>
<p>On to implicit conversions, let's start with <strong>numbers</strong>. CBQN numbers are 64-bit floats, which are a superset of integer types up to 32 bits, and 32-bit floats. So conversions from all these types are exact with no problems. Converting to a smaller integer type requires the float value to fit in that type, while converting to a smaller float type rounds.</p>
<p>Issues show up with <strong>64-bit integer</strong> types because 64-bit floats only have full integer precision from <code><span class='Function'>-</span><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Number'>53</span></code> to <code><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Number'>53</span></code>. <em>Some</em> integers beyond this range are representable, but others aren't: for example <code><span class='Number'>1</span><span class='Function'>+</span><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Number'>53</span></code> rounds to <code><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Number'>53</span></code>. For this reason numbers with absolute value <code><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Number'>53</span></code> and greater error when converting between float and integer. Bare <code><span class='Value'>u64</span></code> and <code><span class='Value'>i64</span></code> types are fine when working with lengths and other things that can't reasonably be that large, but when all the bits are used they should be converted with <code><span class='Value'>i64</span><span class='Head'>:</span><span class='Value'>u32</span></code> or similar.</p>
<p>An <strong>array</strong> or <strong>struct</strong> corresponds to a BQN list, easy enough.</p>
<p>A BQN list or pointer object can be converted to a <strong>pointer</strong>, and a C pointer is always converted to a pointer object‚Äîit can't be converted to a list because the length is unknown, but sometimes a mutable pointer is a convenient way to get a list from a C function. <a href="#pointer-objects">Pointer objects</a> are BQN values designed specifically to encapsulate C pointers. If passed as an argument, its type needs to be compatible with the type for that argument, if it has one. When an argument has an <em>untyped</em> pointer type <code><span class='Value'>*</span></code> or <code><span class='Value'>&amp;</span></code>, it can't take a list as input (what would the elements be converted to?) but any pointer object will be accepted.</p>
<h3 id="explicit-type-conversion"><a class="header" href="#explicit-type-conversion">Explicit type conversion</a></h3>
<p>Either the type as a whole, or any member of a struct, can have a conversion specification like <code><span class='Head'>:</span><span class='Value'>u32</span></code> at the end. The type after the colon uses the same format as C numeric types, with the quality <code><span class='Value'>c</span></code> allowed for characters in addition to <code><span class='Value'>i</span></code>, <code><span class='Value'>u</span></code>, and <code><span class='Value'>f</span></code>. Here CBQN supports the types it uses internally for arrays: <code><span class='Value'>u1</span></code> for booleans, <code><span class='Value'>i8</span></code> to <code><span class='Value'>i32</span></code> and <code><span class='Value'>c8</span></code> to <code><span class='Value'>c32</span></code>, and <code><span class='Value'>f64</span></code>.</p>
<p>With explicit conversion, each C value corresponds to a list of BQN values with the same bit representation. For example, you might use <code><span class='Value'>u64</span><span class='Head'>:</span><span class='Value'>u1</span></code> to represent a 64-bit number as 64 bits (little-endian or least significant first), or <code><span class='Value'>u64</span><span class='Head'>:</span><span class='Value'>c8</span></code> to represent it as 8 characters. Similarly, a pointer can be turned into plain bits and back with <code><span class='Value'>*</span><span class='Head'>:</span><span class='Value'>u1</span></code>. The <code><span class='Head'>:</span></code> also applies to compound values; another case is an argument such as <code><span class='Value'>*i64</span><span class='Head'>:</span><span class='Value'>i32</span></code>, which will be cast from a BQN list of 32-bit ints to a C list of 64-bit ints that's half as long (with an error if the length wasn't even). And <code><span class='Value'>&amp;</span></code> can be used instead of <code><span class='Value'>*</span></code> to get mutated values out, converting back to i32 on the way. Other compound cases have some complications and aren't supported in CBQN currently.</p>
<h2 id="argument-and-result-formats"><a class="header" href="#argument-and-result-formats">Argument and result formats</a></h2>
<p>This section covers how FFI arguments and results are structured in BQN, and collects the ways to tweak it.</p>
<p>The normal case is that <code><span class='Value'>ùï©</span></code> is a list of the arguments. You can pass in <code><span class='Value'>ùï®</span></code> if you really want, but is has to be an empty list. No arguments have been specified as coming from <code><span class='Value'>ùï®</span></code>! You can control where a C argument comes from by sticking <code><span class='Value'>ùï®</span></code> or <code><span class='Value'>ùï©</span></code> to the front (<code><span class='Value'>ùï©</span></code> does nothing, it's already the default). So for example, arguments of <code><span class='String'>&quot;i32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;ùï®i32&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;ùï©i32&quot;</span></code> mean the function has to be called like <code><span class='Bracket'>‚ü®</span><span class='Number'>2</span><span class='Bracket'>‚ü©</span> <span class='Function'>Fn</span> <span class='Number'>3</span><span class='Ligature'>‚Äø</span><span class='Number'>4</span></code>. Then if a C argument is the only one included in its BQN argument, it can have a <code><span class='Function'>&gt;</span></code> at the beginning (either before or after the <code><span class='Value'>ùï®</span></code>/<code><span class='Value'>ùï©</span></code>) meaning that the BQN argument should be that value directly instead of the 1-element list.</p>
<p>If there are no mutable arguments, the result is what it is. Unless it isn't: a result type of <code><span class='String'>&quot;&quot;</span></code> results in a result value of <code><span class='String'>@</span></code>.</p>
<p>Mutable arguments (those with <code><span class='Value'>&amp;</span></code>) all have to be returned as part of the result. If there are any of these, the result is a list consisting of the C result followed by each mutable argument, mutatis mutandis, in the order they appeared in the arguments. Again, the result type can be <code><span class='String'>&quot;&quot;</span></code> to leave it out, so that the result just includes mutable values. It can also be <code><span class='String'>&quot;&amp;&quot;</span></code> if there's exactly one such value, which means it won't be returned as a list.</p>
<p>In the table of examples below, <code><span class='Number'>5</span></code>, <code><span class='Number'>1</span></code>, <code><span class='Number'>0.5</span></code>, and <code><span class='Number'>3</span></code> are used as values for <code><span class='Value'>i8</span></code>, <code><span class='Value'>u1</span></code>, <code><span class='Value'>f64</span></code>, and <code><span class='Value'>i64</span></code> respectively, and <code><span class='Value'>a</span></code> and <code><span class='Value'>b</span></code> are possible list arguments with <code><span class='Value'>am</span></code> and <code><span class='Value'>bm</span></code> indicating modified versions of these.</p>
<table>
<thead>
<tr>
<th>Res</th>
<th>Args</th>
<th>Call</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span class='String'>&quot;i64&quot;</span></code></td>
<td><code><span class='String'>&quot;i8&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u1&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;f64&quot;</span></code></td>
<td><code><span class='Function'>Fn</span> <span class='Bracket'>‚ü®</span><span class='Number'>5</span><span class='Separator'>,</span><span class='Number'>1</span><span class='Separator'>,</span><span class='Number'>0.5</span><span class='Bracket'>‚ü©</span></code></td>
<td><code><span class='Number'>3</span></code></td>
</tr>
<tr>
<td><code><span class='String'>&quot;i64&quot;</span></code></td>
<td><code><span class='String'>&quot;ùï®i8&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;ùï®u1&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;f64&quot;</span></code></td>
<td><code><span class='Bracket'>‚ü®</span><span class='Number'>5</span><span class='Separator'>,</span><span class='Number'>1</span><span class='Bracket'>‚ü©</span> <span class='Function'>Fn</span> <span class='Bracket'>‚ü®</span><span class='Number'>0.5</span><span class='Bracket'>‚ü©</span></code></td>
<td><code><span class='Number'>3</span></code></td>
</tr>
<tr>
<td><code><span class='String'>&quot;&quot;</span></code></td>
<td><code><span class='String'>&quot;i8&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u1&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&gt;ùï®f64&quot;</span></code></td>
<td><code><span class='Number'>0.5</span> <span class='Function'>Fn</span> <span class='Bracket'>‚ü®</span><span class='Number'>5</span><span class='Separator'>,</span><span class='Number'>1</span><span class='Bracket'>‚ü©</span></code></td>
<td><code><span class='String'>@</span></code></td>
</tr>
<tr>
<td><code><span class='String'>&quot;i64&quot;</span></code></td>
<td><code><span class='String'>&quot;&amp;i8&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u1&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&amp;f64&quot;</span></code></td>
<td><code><span class='Function'>Fn</span> <span class='Bracket'>‚ü®</span><span class='Value'>a</span><span class='Separator'>,</span><span class='Number'>1</span><span class='Separator'>,</span><span class='Value'>b</span><span class='Bracket'>‚ü©</span></code></td>
<td><code><span class='Bracket'>‚ü®</span><span class='Number'>3</span><span class='Separator'>,</span><span class='Value'>am</span><span class='Separator'>,</span><span class='Value'>bm</span><span class='Bracket'>‚ü©</span></code></td>
</tr>
<tr>
<td><code><span class='String'>&quot;&quot;</span></code></td>
<td><code><span class='String'>&quot;&amp;i8&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u1&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;&amp;f64&quot;</span></code></td>
<td><code><span class='Function'>Fn</span> <span class='Bracket'>‚ü®</span><span class='Value'>a</span><span class='Separator'>,</span><span class='Number'>1</span><span class='Separator'>,</span><span class='Value'>b</span><span class='Bracket'>‚ü©</span></code></td>
<td><code><span class='Bracket'>‚ü®</span><span class='Value'>am</span><span class='Separator'>,</span><span class='Value'>bm</span><span class='Bracket'>‚ü©</span></code></td>
</tr>
<tr>
<td><code><span class='String'>&quot;&amp;&quot;</span></code></td>
<td><code><span class='String'>&quot;&amp;i8&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;u1&quot;</span><span class='Ligature'>‚Äø</span><span class='String'>&quot;f64&quot;</span></code></td>
<td><code><span class='Function'>Fn</span> <span class='Bracket'>‚ü®</span><span class='Value'>a</span><span class='Separator'>,</span><span class='Number'>1</span><span class='Separator'>,</span><span class='Number'>0.5</span><span class='Bracket'>‚ü©</span></code></td>
<td><code><span class='Value'>am</span></code></td>
</tr>
</tbody>
</table>
<h3 id="pointer-objects"><a class="header" href="#pointer-objects">Pointer objects</a></h3>
<p><a href="../spec/system.html#pointer-objects">specification</a></p>
